"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const hash_1 = require("./hash");
describe("sha1 is deterministic", () => {
    let value = Math.random().toString();
    test("random string", () => {
        expect((0, hash_1.calculateSHA1)(value)).toBe((0, hash_1.calculateSHA1)(value));
        expect((0, hash_1.calculateSHA1)(value)).not.toBe((0, hash_1.calculateSHA1)(""));
    });
    test("empty object", () => {
        expect((0, hash_1.calculateSHA1)({})).toBe((0, hash_1.calculateSHA1)({}));
        expect((0, hash_1.calculateSHA1)({})).not.toBe((0, hash_1.calculateSHA1)(""));
    });
    test("empty keys", () => {
        expect((0, hash_1.calculateSHA1)({}, [])).toBe((0, hash_1.calculateSHA1)({}, []));
        expect((0, hash_1.calculateSHA1)({ a: 1 }, [])).toBe((0, hash_1.calculateSHA1)({}, []));
        expect((0, hash_1.calculateSHA1)({}, [])).not.toBe((0, hash_1.calculateSHA1)(""));
    });
    test("same keys", () => {
        expect((0, hash_1.calculateSHA1)({ a: 1 }, ["a"])).toBe((0, hash_1.calculateSHA1)({ a: 1 }, ["a"]));
        expect((0, hash_1.calculateSHA1)({ a: 1 }, ["a"])).not.toBe((0, hash_1.calculateSHA1)({ a: 2 }, ["a"]));
    });
    test("multiple keys", () => {
        expect((0, hash_1.calculateSHA1)({ a: 1, b: 2 })).toBe((0, hash_1.calculateSHA1)({ b: 2, a: 1 }));
        expect((0, hash_1.calculateSHA1)({ a: 1, b: 2 })).not.toBe((0, hash_1.calculateSHA1)({ a: 2, b: 1 }));
    });
    test("nested keys", () => {
        expect((0, hash_1.calculateSHA1)({ a: 1, b: { c: 2, d: 3 } })).toBe((0, hash_1.calculateSHA1)({ b: { d: 3, c: 2 }, a: 1 }));
        expect((0, hash_1.calculateSHA1)({ a: 1, b: { c: 2, d: 3 } })).toBe((0, hash_1.calculateSHA1)({ b: {}, a: 1 }));
        expect((0, hash_1.calculateSHA1)({ a: 1, b: { c: 2 } })).not.toBe((0, hash_1.calculateSHA1)({ a: 2, b: { c: 1 } }));
    });
    test("JSON not deterministic", () => {
        expect(JSON.stringify({ a: 1, b: 2 })).not.toBe(JSON.stringify({ b: 2, a: 1 }));
    });
});
